# This file standardizes all covariates.
# From cancer covariates to
library(tidyverse)
library(BSgenome)
library(Biostrings)
library(Biostrings)
library(BSgenome.Hsapiens.UCSC.hg19)
library(GenomicRanges)
library(GenomicFeatures)
library(rtracklayer)

standardize_scores_1kb <- function(gr,
                                   trans_log2 = TRUE,
                                   nugget_log2 = 0.1,
                                   reference_cutoff = NULL,
                                   cap_quantile99.99 = TRUE, ...){
  # Import blacklist and regions with gaps
  blacklist <- rtracklayer::import("~/SigPoisProcess/data/ENCODE_pvalues/hg19-blacklist.v2.bed")
  gap_gr <- rtracklayer::import("~/SigPoisProcess/data/regions_to_exclude/gaps_hg19.bed")

  # Adjust bin sizes to remove blacklist and gaps
  BinWeight <- width(gr)
  score <- gr$score
  # Remove gaps
  overlapGaps <- findOverlaps(gr, gap_gr)
  rangesGaps <- gr[queryHits(overlapGaps)]
  # Find the number of ACGT in the gap regions, and adjust the bin sizes to remove
  # the NNNNN sequences
  seqs <- getSeq(BSgenome.Hsapiens.UCSC.hg19, rangesGaps)
  countACGT <- rowSums((Biostrings::alphabetFrequency(seqs))[, c("A", "C", "G", "T")])
  BinWeight[queryHits(overlapGaps)] <- countACGT
  # Exlude now the blacklist as well
  overlap_blackList <- findOverlaps(gr, blacklist)
  pairs <- Pairs(gr[queryHits(overlap_blackList)], blacklist[subjectHits(overlap_blackList)])
  grIntersect <- pintersect(pairs)
  BinWeight[queryHits(overlap_blackList)] <- pmax(BinWeight[queryHits(overlap_blackList)] - width(grIntersect), 0)
  score[BinWeight == 0] <- 0 # Replace it with 0, knowing that we will remove it afterwards

  ids <- BinWeight > 0
  # Transform the scores now
  scores_tr <- score[ids]# * BinWeight[BinWeight > 0]/1000 # 1000 because we are dealing with 1kb intervals
  if(cap_quantile99.99) {
    scores_tr <- pmin(scores_tr, quantile(scores_tr, 0.9999))
  }
  if(trans_log2){
    if(is.null(reference_cutoff)){
      scores_tr <- log2((scores_tr)/mean(scores_tr * BinWeight[ids]/1000) + nugget_log2)
    } else {
      scores_tr <- log2(scores_tr/reference_cutoff + nugget_log2)
    }
  }
  # Scale now the score
  scores_scaled <- scale(scores_tr)#(scores_tr - median(scores_tr))/sd(scores_tr)
  # Add positive and negative part of the score
  enrich <- pmax(0, scores_scaled)
  depl <- pmax(0, -scores_scaled)
  # Merge with gr object
  gr$bin_weight <- BinWeight
  gr$score_tr <- 0
  gr$score_scaled <- 0
  gr$score_plus <- 0
  gr$score_minus <- 0

  gr[ids]$score_tr <- scores_tr
  gr[ids]$score_scaled <- scores_scaled
  gr[ids]$score_plus <- pmax(0, scores_scaled)
  gr[ids]$score_minus <- pmax(0, -scores_scaled)

  # Add chromosome chrY with width and values == 0 if absent
  if(!("chrY" %in% seqnames(gr))) {
    # Details of chrY
    chrY_length <- 59373566
    bin_size <- 1000
    starts <- seq(1, chrY_length, by=bin_size)
    ends <- pmin(starts + bin_size - 1, chrY_length)
    n_bins <- length(starts)
    # Create GRanges for chrY
    gr_chrY <- GRanges(
      seqnames=Rle("chrY"),
      ranges=IRanges(start=starts, end=ends),
      strand=Rle("*"))
    # Create a data frame of zeros with the same column names as mcols(gr)
    mcols_names <- colnames(mcols(gr))
    chrY_mcols <- as.data.frame(matrix(0, nrow=n_bins, ncol=length(mcols_names)))
    colnames(chrY_mcols) <- mcols_names
    mcols(gr_chrY) <- chrY_mcols
    gr <- c(gr, gr_chrY)
  }
  return(gr)
}

genome <- BSgenome.Hsapiens.UCSC.hg19

# CTCF and Histone modification
# Log2 transform the fold change. Use reference of 1 (instead of the mean)
dir_in <- "~/SigPoisProcess/data/ENCODE_foldchange/Cancer_covariates/"
dir_out <- "~/SigPoisProcess/data/Covariates_standardized/"
files <- list.files(dir_in)
for(i in 1:length(files)){
  print(files[i])
  f <- paste0(dir_in, files[i])
  gr <- import(f)
  gr <- standardize_scores_1kb(gr, trans_log2 = TRUE, reference_cutoff = 1)
  saveRDS(gr, file = paste0(dir_out, gsub(".bigWig", "_standardized.bigWig.rds.gzip", files[i])),
          compress = "gzip")

}

# DNAse. We take the log2, using the reference as the mean.
dir_in <- "~/SigPoisProcess/data/ENCODE_pvalues/Cancer_covariates/"
files <- list.files(dir_in)
files <- files[grepl("DNAse", files)]
for(i in 1:length(files)){
  print(files[i])
  f <- paste0(dir_in, files[i])
  gr <- import(f)
  gr <- standardize_scores_1kb(gr, trans_log2 = TRUE)
  out_name <- paste0(dir_out, gsub(".bigWig", "_1kb_standardized.bigWig.rds.gzip", files[i]))
  out_name <- gsub("DNAse-seq", "DNAse_seq", out_name)
  saveRDS(gr, file = out_name, compress = "gzip")

}

#----------------
# Nucleosome occupancy
#----------------
# Nucleosome density signal maps (bedgraph and bigwig files) were generated by
# first shifting reads by 74 bp in the 5´ to 3´ direction and counting the total n
# umber of reads starting at each genomic coordinate on both strands. These counts
# are then smoothed using un-normalized kernel density smoothing with a triweight kernel.
# A bandwidth of 30 bp is used which is equivalent to a smoothing window of 60 bp.
# The smoothed counts at each position are then divided by the expected number of
# reads from an equivalent uniform distribution of reads in a ± 30 bp window around
# that position. If less than 25% of the positions in a ± 30 bp window around a
# genomic location are uniquely mappable or if the location is part of an assembly
# gap, the signal value at that position is considered unreliable and not recorded
# in the signal files. Hence, genomic coordinates that do not have any associated
# signal value should be considered missing or unreliable data. Genomic coordinates
# associated with a signal value of 0 are reliably mapable but do not have any signal
# in the dataset.
gr <- import("~/SigPoisProcess/data/ENCODE_pvalues/NuclOccupancy/GSM920557_hg19_wgEncodeSydhNsomeK562Sig_1kb.bigWig")
gr <- standardize_scores_1kb(gr, trans_log2 = TRUE, reference_cutoff = 1)
seqlengths(gr) <- seqlengths(genome)[1:24]
saveRDS(gr, file = paste0(dir_out, "male_NuclOccup_1kb_standardized.bigWig.rds.gzip"),
        compress = "gzip")

gr <- import("~/SigPoisProcess/data/ENCODE_pvalues/NuclOccupancy/GSM920557_hg19_wgEncodeSydhNsomeK562Sig_1kb.bigWig")
gr <- standardize_scores_1kb(gr, trans_log2 = TRUE, reference_cutoff = 1)
seqlengths(gr) <- seqlengths(genome)[1:24]
saveRDS(gr, file = paste0(dir_out, "female_NuclOccup_1kb_standardized.bigWig.rds.gzip"),
        compress = "gzip")

#----------------
# Replication timing. We only standardize it, not taking any log
#----------------
# Uniquely mapping high-quality reads were mapped to the genome minus the Y
# chromosome. Replication signals within each six cell cycle fraction were derived
# from the density of sequence tags mapping within a 50 kb sliding window
# (stepped 1 kb across the genome); these densities were normalized to 4 million
# tags per genome. To avoid variation due to copy number or sequence bias, cell
# cycle-specific replication signals at each location were determined as a percentage
# of the sum of the six normalized tag density signals (Percentage-normalized Signal).
# To transform the six fraction replication signals into one track (Wavelet-smoothed Signal),
# the percentage-normalized signals at each location were used to calculate a weighted
# average value based on the average DNA content of each fraction according to flow
# cytometry [higher values correspond to earlier replication;
# formula=(0.917*G1b)+(0.750*S1)+(0.583*S2)+(0.417*S3)+(0.250*S4)+(0*G2)].
# These weighted average data were smoothed by wavelet transformation [J7 level,
# corresponding to a scale of 128 kb; see Thurman et al. (2007)].
gr <- import("~/SigPoisProcess/data/ENCODE_pvalues/ReplTiming/Repliseq_WaveSignal_1kb/wgEncodeUwRepliSeqNhekWaveSignalRep1.bigWig")
gr <- standardize_scores_1kb(gr, trans_log2 = FALSE)
seqlengths(gr) <- seqlengths(genome)[1:24]
saveRDS(gr, file = paste0(dir_out, "male_RepliTiming_1kb_standardized.bigWig.rds.gzip"),
        compress = "gzip")

gr <- import("~/SigPoisProcess/data/ENCODE_pvalues/ReplTiming/Repliseq_WaveSignal_1kb/wgEncodeUwRepliSeqNhekWaveSignalRep1.bigWig")
gr <- standardize_scores_1kb(gr, trans_log2 = FALSE)
seqlengths(gr) <- seqlengths(genome)[1:24]
saveRDS(gr, file = paste0(dir_out, "female_RepliTiming_1kb_standardized.bigWig.rds.gzip"),
        compress = "gzip")

# Methylation. We only standardize it, not taking any log
dir_in <- "~/SigPoisProcess/data/ENCODE_pvalues/Cancer_covariates/"
files <- list.files(dir_in)
files <- files[grepl("Methylation", files)]
tumor <- str_split(files, "_", simplify = TRUE)[, 1]
for(i in 1:length(files)){
  print(files[i])
  f <- paste0(dir_in, files[i])
  # Male
  gr <- import(f)
  gr <- standardize_scores_1kb(gr, trans_log2 = FALSE)
  seqlengths(gr) <- seqlengths(genome)[1:24]
  saveRDS(gr, file = paste0(dir_out, tumor[i], "_male_Methylation_1kb_standardized.bigWig.rds.gzip"),
          compress = "gzip")
  # female
  gr <- import(f)
  gr <- gr[gr@seqnames != "chrY"]
  gr <- standardize_scores_1kb(gr, trans_log2 = FALSE)
  seqlengths(gr) <- seqlengths(genome)[1:24]
  saveRDS(gr, file = paste0(dir_out, tumor[i], "_female_Methylation_1kb_standardized.bigWig.rds.gzip"),
          compress = "gzip")

}

# GC_content. We only standardize it, not taking any log
# Male
gr <- import("~/SigPoisProcess/data/ENCODE_pvalues/gc_content/gc_content_1kb.bigWig")
gr <- standardize_scores_1kb(gr, trans_log2 = FALSE)
saveRDS(gr, file = paste0(dir_out, "male_GC_1kb_standardized.bigWig.rds.gzip"), compress = "gzip")
# Female
gr <- import("~/SigPoisProcess/data/ENCODE_pvalues/gc_content/gc_content_1kb.bigWig")
gr <- gr[gr@seqnames != "chrY"]
gr <- standardize_scores_1kb(gr, trans_log2 = FALSE)
saveRDS(gr, file = paste0(dir_out, "female_GC_1kb_standardized.bigWig.rds.gzip"), compress = "gzip")



